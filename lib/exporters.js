/**
 * Export Formatters
 *
 * Convert extracted design tokens to various framework formats
 */

/**
 * Convert extracted design tokens to Tailwind CSS configuration
 * @param {Object} data - Extraction results from extractBranding()
 * @returns {string} Tailwind config file content as JavaScript
 */
export function exportToTailwind(data) {
  const config = {
    theme: {
      colors: extractTailwindColors(data.colors),
      fontFamily: extractTailwindFontFamilies(data.typography),
      fontSize: extractTailwindFontSizes(data.typography),
      fontWeight: extractTailwindFontWeights(data.typography),
      spacing: extractTailwindSpacing(data.spacing),
      borderRadius: extractTailwindBorderRadius(data.borderRadius),
      borderWidth: extractTailwindBorderWidths(data.borders),
      boxShadow: extractTailwindShadows(data.shadows),
      screens: extractTailwindBreakpoints(data.breakpoints),
    },
  };

  // Generate JavaScript config file
  return `/** @type {import('tailwindcss').Config} */
export default ${JSON.stringify(config, null, 2)};

// Alternative CommonJS format:
// module.exports = ${JSON.stringify(config, null, 2)};

/**
 * Generated by dembrandt
 * Source: ${data.url}
 * Extracted: ${data.extractedAt}
 *
 * Usage:
 * 1. Copy this file to your project root as tailwind.config.js
 * 2. Customize colors, spacing, and other values as needed
 * 3. Run: npx tailwindcss -i ./src/input.css -o ./dist/output.css
 *
 * Learn more: https://tailwindcss.com/docs/configuration
 */
`;
}

/**
 * Extract and format colors for Tailwind
 */
function extractTailwindColors(colors) {
  const tailwindColors = {};

  // Add semantic colors
  if (colors.semantic) {
    Object.entries(colors.semantic).forEach(([role, color]) => {
      if (color) {
        tailwindColors[role] = normalizeColorToHex(color);
      }
    });
  }

  // Add CSS variables as color tokens
  if (colors.cssVariables) {
    Object.entries(colors.cssVariables).forEach(([varName, color]) => {
      // Convert --color-primary to primary
      const key = varName
        .replace(/^--/, '')
        .replace(/^(color|bg|text)-/, '')
        .replace(/-/g, '-');

      if (!tailwindColors[key]) {
        tailwindColors[key] = normalizeColorToHex(color);
      }
    });
  }

  // Add palette colors with confidence-based naming
  if (colors.palette) {
    const highConfColors = colors.palette.filter(c => c.confidence === 'high' || c.confidence === 'medium');

    // Group similar colors and create shade scales
    const colorGroups = {};
    highConfColors.slice(0, 20).forEach((colorData, index) => {
      const hex = normalizeColorToHex(colorData.color);
      const colorName = colorData.sources?.[0] || `brand-${index + 1}`;

      // Clean up color name for Tailwind
      const cleanName = colorName
        .replace(/^\./, '')
        .replace(/[^a-z0-9-]/gi, '-')
        .replace(/--+/g, '-')
        .replace(/^-|-$/g, '')
        .toLowerCase();

      if (cleanName && cleanName.length > 0 && cleanName.length < 30) {
        tailwindColors[cleanName] = hex;
      }
    });
  }

  return tailwindColors;
}

/**
 * Extract font families for Tailwind
 */
function extractTailwindFontFamilies(typography) {
  const families = {};

  if (!typography || !typography.styles) return families;

  // Extract unique font families
  const uniqueFamilies = new Set();
  typography.styles
    .filter(s => s.confidence === 'high')
    .forEach(style => {
      const family = style.fontFamily.split(',')[0].replace(/['"]/g, '').trim();
      if (family && family !== 'inherit' && family !== 'initial') {
        uniqueFamilies.add(family);
      }
    });

  // Create font family tokens
  const familyArray = Array.from(uniqueFamilies);
  if (familyArray.length > 0) {
    families.sans = [familyArray[0], 'ui-sans-serif', 'system-ui', 'sans-serif'];

    if (familyArray.length > 1) {
      families.display = [familyArray[1], 'ui-sans-serif', 'system-ui', 'sans-serif'];
    }

    if (familyArray.length > 2) {
      families.body = [familyArray[2], 'ui-sans-serif', 'system-ui', 'sans-serif'];
    }
  }

  return families;
}

/**
 * Extract font sizes for Tailwind
 */
function extractTailwindFontSizes(typography) {
  const sizes = {};

  if (!typography || !typography.styles) return sizes;

  // Group font sizes by semantic meaning
  const sizeMap = new Map();

  typography.styles
    .filter(s => s.confidence === 'high')
    .forEach(style => {
      const context = style.contexts[0];
      const sizeRem = style.fontSizeRem;
      const lineHeight = style.lineHeight;

      // Map contexts to Tailwind size names
      const sizeNames = {
        'h1': 'heading-1',
        'h2': 'heading-2',
        'h3': 'heading-3',
        'h4': 'heading-4',
        'h5': 'heading-5',
        'h6': 'heading-6',
        'p': 'body',
        'button': 'button',
        'a': 'link',
      };

      const sizeName = sizeNames[context] || context;

      if (!sizeMap.has(sizeName)) {
        sizeMap.set(sizeName, [sizeRem, { lineHeight }]);
      }
    });

  // Convert to Tailwind format
  sizeMap.forEach((value, key) => {
    sizes[key] = value;
  });

  return sizes;
}

/**
 * Extract font weights for Tailwind
 */
function extractTailwindFontWeights(typography) {
  const weights = {};

  if (!typography || !typography.styles) return weights;

  // Extract unique font weights
  const uniqueWeights = new Set();
  typography.styles
    .filter(s => s.confidence === 'high')
    .forEach(style => {
      const weight = style.fontWeight;
      if (weight && weight !== 'normal') {
        uniqueWeights.add(parseInt(weight));
      }
    });

  // Map to Tailwind weight names
  const weightNames = {
    100: 'thin',
    200: 'extralight',
    300: 'light',
    400: 'normal',
    500: 'medium',
    600: 'semibold',
    700: 'bold',
    800: 'extrabold',
    900: 'black',
  };

  Array.from(uniqueWeights).forEach(weight => {
    const name = weightNames[weight];
    if (name) {
      weights[name] = String(weight);
    }
  });

  return weights;
}

/**
 * Extract spacing scale for Tailwind
 */
function extractTailwindSpacing(spacing) {
  const scale = {};

  if (!spacing || !spacing.commonValues) return scale;

  // Convert spacing values to Tailwind format
  spacing.commonValues.forEach((value, index) => {
    // Use numeric keys (0, 1, 2, 4, 8, 16, etc.) matching the pixel values
    const pxValue = parseFloat(value.px);

    // Create sensible keys based on the spacing scale
    let key;
    if (pxValue <= 4) {
      key = String(pxValue); // 0, 1, 2, 3, 4
    } else if (pxValue % 4 === 0) {
      key = String(pxValue); // 8, 12, 16, 20, 24, etc.
    } else {
      key = value.px.replace('px', ''); // Keep original value
    }

    scale[key] = value.rem;
  });

  return scale;
}

/**
 * Extract border radius for Tailwind
 */
function extractTailwindBorderRadius(borderRadius) {
  const radii = {};

  if (!borderRadius || !borderRadius.values) return radii;

  // Filter high confidence values
  const values = borderRadius.values.filter(r =>
    r.confidence === 'high' || r.confidence === 'medium'
  );

  // Map to Tailwind naming convention
  values.forEach((radius, index) => {
    const value = radius.value;
    const numericValue = parseFloat(value);

    // Create semantic names
    if (numericValue === 0 || value === '0px') {
      radii.none = '0';
    } else if (numericValue < 4) {
      radii.sm = value;
    } else if (numericValue >= 4 && numericValue < 8) {
      radii.DEFAULT = value;
    } else if (numericValue >= 8 && numericValue < 12) {
      radii.md = value;
    } else if (numericValue >= 12 && numericValue < 16) {
      radii.lg = value;
    } else if (numericValue >= 16 && numericValue < 24) {
      radii.xl = value;
    } else if (numericValue >= 24 || value.includes('%')) {
      radii['2xl'] = value;
    }
  });

  return radii;
}

/**
 * Extract border widths for Tailwind
 */
function extractTailwindBorderWidths(borders) {
  const widths = {};

  if (!borders || !borders.widths) return widths;

  borders.widths.forEach((border, index) => {
    const width = border.width;
    const numericValue = parseFloat(width);

    // Map to Tailwind convention
    if (numericValue === 0 || width === '0px') {
      widths[0] = '0';
    } else if (numericValue === 1) {
      widths.DEFAULT = width;
    } else if (numericValue === 2) {
      widths[2] = width;
    } else if (numericValue === 4) {
      widths[4] = width;
    } else if (numericValue === 8) {
      widths[8] = width;
    } else {
      widths[numericValue] = width;
    }
  });

  return widths;
}

/**
 * Extract box shadows for Tailwind
 */
function extractTailwindShadows(shadows) {
  const tailwindShadows = {};

  if (!shadows || shadows.length === 0) return tailwindShadows;

  // Filter high confidence shadows
  const highConfShadows = shadows.filter(s =>
    s.confidence === 'high' || s.confidence === 'medium'
  );

  // Map to Tailwind naming convention (sm, DEFAULT, md, lg, xl, 2xl)
  const names = ['sm', 'DEFAULT', 'md', 'lg', 'xl', '2xl', '3xl'];

  highConfShadows.slice(0, names.length).forEach((shadow, index) => {
    tailwindShadows[names[index]] = shadow.shadow;
  });

  return tailwindShadows;
}

/**
 * Extract breakpoints for Tailwind
 */
function extractTailwindBreakpoints(breakpoints) {
  const screens = {};

  if (!breakpoints || breakpoints.length === 0) return screens;

  // Map to Tailwind naming convention
  const names = ['sm', 'md', 'lg', 'xl', '2xl'];

  // Sort breakpoints from smallest to largest
  const sorted = [...breakpoints].sort((a, b) => {
    return parseFloat(a.px) - parseFloat(b.px);
  });

  sorted.slice(0, names.length).forEach((bp, index) => {
    screens[names[index]] = bp.px;
  });

  return screens;
}

/**
 * Normalize color to hex format for Tailwind
 */
function normalizeColorToHex(color) {
  // Convert rgb/rgba to hex
  const rgbaMatch = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)/);
  if (rgbaMatch) {
    const r = parseInt(rgbaMatch[1]).toString(16).padStart(2, '0');
    const g = parseInt(rgbaMatch[2]).toString(16).padStart(2, '0');
    const b = parseInt(rgbaMatch[3]).toString(16).padStart(2, '0');

    // If alpha is present and not 1, include it
    if (rgbaMatch[4] && parseFloat(rgbaMatch[4]) !== 1) {
      const a = Math.round(parseFloat(rgbaMatch[4]) * 255).toString(16).padStart(2, '0');
      return `#${r}${g}${b}${a}`;
    }

    return `#${r}${g}${b}`;
  }

  // Return hex colors as-is
  if (color.startsWith('#')) {
    return color.toLowerCase();
  }

  // Return other formats as-is (named colors, etc.)
  return color;
}
